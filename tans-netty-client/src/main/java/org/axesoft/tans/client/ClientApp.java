/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.axesoft.tans.client;

import io.netty.util.concurrent.Future;
import org.apache.commons.cli.*;
import org.apache.commons.lang3.Range;
import org.apache.commons.lang3.time.StopWatch;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

public class ClientApp {

    public static class Args {
        private String servers = "localhost:8081;localhost:8082;localhost:8083";
        private int clientNumber = 1;
        private int round = 1;
        private int printInterval = 100;
        private boolean ignoreLeader = false;
    }

    private static Args parseArgs(String[] params){
        Options options = new Options();
        options.addOption("s", "servers", true, "server addresses in syntax of 'addr1:port1;addr2:port2'");
        options.addOption("c", "client-number", true, "Num of parallel clients, default is 1");
        options.addOption("k", "kilo", true, "How many kilo requests, default is 100");
        options.addOption("i", "ignore-leader", false, "Ignore the leader, default is false");
        options.addOption("p", "print-interval", true,"Print result every given times, default 0 means never");

        CommandLineParser parser = new DefaultParser();
        CommandLine line = null;
        try {
            line = parser.parse(options, params);
        }
        catch (ParseException e) {
            throw new RuntimeException(e);
        }

        Args args = new Args();
        if(line.hasOption('s')){
            args.servers = line.getOptionValue('s');
        }

        if(line.hasOption('c')){
            args.clientNumber = Integer.parseInt(line.getOptionValue('c'));
        }

        if(line.hasOption('k')){
            args.round = Integer.parseInt(line.getOptionValue('k'));
        }

        if(line.hasOption('i')){
            args.ignoreLeader = true;
        }

        if(line.hasOption('p')){
            args.printInterval = Integer.parseInt(line.getOptionValue('p'));
        }

        return args;
    }
    public static void main(String[] args) throws Exception {
        System.setProperty("node-id", "client");

        Args arg = parseArgs(args);

        int n = 1000;

        int p = arg.clientNumber;

        final CountDownLatch startLatch = new CountDownLatch(1);

        final CountDownLatch endLatch = new CountDownLatch(p);

        final AtomicLong millis = new AtomicLong(0);
        final AtomicLong times = new AtomicLong(0);

        final ResultChecker checker = new ResultChecker((p * 3) / 2);

        for (int j = 0; j < p; j++) {
            new Thread(() -> {
                try {
                    new TansClientRunner()
                            .setServers(arg.servers)
                            .setK(arg.round)
                            .setN(n)
                            .setPrintInterval(arg.printInterval)
                            .setStartLatch(startLatch)
                            .setChecker(checker)
                            .setMillis(millis)
                            .setTimes(times)
                            .setIgnoreLeader(arg.ignoreLeader)
                            .execute();
                }
                catch (Exception e) {
                    System.out.println("Exec end with exception");
                    e.printStackTrace();
                }
                finally {
                    endLatch.countDown();
                }
            }, "Worker-" + j).start();
        }

        Thread.sleep(5000);
        System.out.println("Start " + new Date());
        startLatch.countDown();

        StopWatch watch = StopWatch.createStarted();

        endLatch.await();
        System.out.println("End " + new Date());

        watch.stop();
        double sec = watch.getTime(TimeUnit.MILLISECONDS) / 1000.0;

        System.out.println(String.format("Total finish %d in %.2f seconds, OPS is %.1f",
                times.get(), sec, times.get() / sec));

        checker.printCheckResult();
    }

    public static class TansClientRunner {
        private String servers;
        private int k;
        private int n;
        private int printInterval;
        private boolean ignoreLeader;
        private CountDownLatch startLatch;
        private ResultChecker checker;
        private AtomicLong millis;
        private AtomicLong times;

        public void execute() throws Exception {
            TansClientBootstrap cb = new TansClientBootstrap(servers);
            final TansClient client = cb.getClient();
            final int interval = this.printInterval > 10 ? this.printInterval + (int) (Math.random() * 100) : this.printInterval;

            Thread.sleep(1000);
            startLatch.await();

            StopWatch watch = StopWatch.createStarted();
            int count = 0;
            try {
                for (int m = 0; m < k; m++) {
                    for (int i = 0; i < n; i++) {
                        count++;
                        String key = "entity-id-" + (count % 2000);
                        Future<Range<Long>> future = client.acquire(key, 1 + (i % 10), this.ignoreLeader);
                        Range<Long> r = null;
                        try {
                            r = future.get(1, TimeUnit.SECONDS);
                        }
                        catch (TimeoutException e) {
                            System.out.println("Timeout when for acquire " + key);
                            return;
                        }
                        checker.accept(key, r.getMinimum(), r.getMaximum());
                        if (interval != 0  && count % interval == 0) {
                            System.out.println(String.format("[%s], %d, %s, %s", Thread.currentThread().getName(), count, key, r.toString()));
                        }
                    }
                }
            }
            finally {
                watch.stop();
                long m = watch.getTime(TimeUnit.MILLISECONDS);
                double sec = m / 1000.0;

                millis.addAndGet(m);
                times.addAndGet(count);
                cb.close();

                System.out.println(String.format("%s finish %d in %.2f seconds, OPS is %.1f, DUR is %.1f ms",
                        Thread.currentThread().getName(), count, sec, count / sec, ((double) m) / count));
            }
        }

        public TansClientRunner setServers(String servers) {
            this.servers = servers;
            return this;
        }

        public TansClientRunner setK(int k) {
            this.k = k;
            return this;
        }

        public TansClientRunner setN(int n) {
            this.n = n;
            return this;
        }

        public TansClientRunner setPrintInterval(int printInterval) {
            this.printInterval = printInterval;
            return this;
        }

        public TansClientRunner setStartLatch(CountDownLatch startLatch) {
            this.startLatch = startLatch;
            return this;
        }

        public TansClientRunner setChecker(ResultChecker checker) {
            this.checker = checker;
            return this;
        }

        public TansClientRunner setMillis(AtomicLong millis) {
            this.millis = millis;
            return this;
        }

        public TansClientRunner setTimes(AtomicLong times) {
            this.times = times;
            return this;
        }

        public TansClientRunner setIgnoreLeader(boolean ignoreLeader) {
            this.ignoreLeader = ignoreLeader;
            return this;
        }
    }

    public static class ResultChecker {
        private int limit;
        ConcurrentMap<String, RangeCombinator> combinatorMap = new ConcurrentHashMap<>();

        public ResultChecker(int limit) {
            this.limit = limit;
        }

        public void accept(String key, long low, long high) {
            RangeCombinator combinator = this.combinatorMap.computeIfAbsent(key, k -> new RangeCombinator(k, this.limit));
            combinator.accept(low, high);
        }

        public void printCheckResult() {
            List<String> keys = new ArrayList<>(combinatorMap.keySet());
            keys.sort(String::compareTo);

            boolean errorOccur = false;
            for (String key : keys) {
                RangeCombinator c = combinatorMap.get(key);
                if (c.getErrMsg() != null) {
                    errorOccur = true;
                    System.out.println(key + ": " + c.getErrMsg());
                }
            }

            if (!errorOccur) {
                System.out.println("All " + keys.size() + " keys are ok");
            }
        }
    }

    public static class RangeCombinator {
        private String key;
        private int limit;
        private long last = 0;
        private String errMsg;
        private SortedSet<Range<Long>> ranges = new TreeSet<>(Comparator.comparingLong(Range::getMinimum));

        public RangeCombinator(String key, int limit) {
            this.limit = limit;
            this.key = key;
        }

        public synchronized void accept(long low, long high) {
            if (errMsg != null) {
                return;
            }

            int size = ranges.size();
            ranges.add(Range.between(low, high));
            if (ranges.size() == size) {
                errMsg = String.format("Overlapped [%d, %d]", low, high);
                return;
            }

            if (ranges.size() > this.limit) {
                tryConcat(this.limit + 1);
            }
        }

        public String getErrMsg() {
            if (errMsg == null) {
                tryConcat(0);
            }

            return this.errMsg;
        }

        private void tryConcat(int allowRemain) {
            while (!this.ranges.isEmpty()) {
                Range<Long> r0 = ranges.first();

                if (last == 0 || r0.getMinimum() == last + 1) {
                    last = r0.getMaximum();
                    ranges.remove(r0);
                }
                else {
                    if (r0.getMinimum() <= last) {
                        errMsg = String.format("Overlapped [%d, %d]", r0.getMinimum(), r0.getMaximum());
                        break;
                    }
                    if (r0.getMinimum() > last + 1) {
                        if (ranges.size() > allowRemain) {
                            errMsg = String.format("gap between %d, %s", last, r0.toString());
                        }
                        break;
                    }
                }
            }
        }
    }
}
