/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.axesoft.tans.client;

import org.apache.commons.cli.*;
import org.apache.commons.lang3.Range;
import org.apache.commons.lang3.time.StopWatch;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

public class ClientApp {

    public static class Settings {
        private String servers = "localhost:8081;localhost:8082;localhost:8083";
        private int clientNumber = 1;
        private int times = 1;
        private int printInterval = 100;
        private boolean ignoreLeader = false;
        private String prefix = "entity-id";
        private String token = "0BC9F3";
        private int keyNumber = 1000;
        private boolean forever=false;
    }

    private static Settings parseArgs(String[] params) {
        Options options = new Options();
        options.addOption("s", "servers", true, "server addresses in syntax of 'addr1:port1;addr2:port2'");
        options.addOption("c", "client-number", true, "Num of parallel clients, default is 1");
        options.addOption("t", "times", true, "How many requests, default is 100");
        options.addOption("k", "key-number", true, "Number of keys");
        options.addOption("i", "ignore-leader", false, "Ignore the leader, default is false");
        options.addOption("p", "print-interval", true, "Print result every given times, default 0 means never");
        options.addOption("T", "token", true, "token for API access");
        options.addOption("r", "key-prefix", true, "The prefix of require key");
        options.addOption("f", "forever", false, "Let test run again and again");

        CommandLineParser parser = new DefaultParser();
        CommandLine line = null;
        try {
            line = parser.parse(options, params);
        }
        catch (ParseException e) {
            throw new RuntimeException(e);
        }

        Settings settings = new Settings();
        if (line.hasOption('s')) {
            settings.servers = line.getOptionValue('s');
        }

        if (line.hasOption('c')) {
            settings.clientNumber = Integer.parseInt(line.getOptionValue('c'));
        }

        if (line.hasOption('t')) {
            settings.times = Integer.parseInt(line.getOptionValue('t'));
        }

        if (line.hasOption('k')) {
            settings.keyNumber = Integer.parseInt(line.getOptionValue('k'));
        }

        if (line.hasOption('i')) {
            settings.ignoreLeader = true;
        }

        if (line.hasOption('p')) {
            settings.printInterval = Integer.parseInt(line.getOptionValue('p'));
        }

        if (line.hasOption('T')) {
            settings.token = line.getOptionValue('T');
        }

        if (line.hasOption('r')) {
            settings.prefix = line.getOptionValue('r');
        }

        if(line.hasOption('f')){
            settings.forever = true;
        }

        return settings;
    }

    private static void run(Settings settings) throws Exception {
        final CountDownLatch startLatch = new CountDownLatch(1);

        final CountDownLatch endLatch = new CountDownLatch(settings.clientNumber);

        final AtomicLong millis = new AtomicLong(0);
        final AtomicLong times = new AtomicLong(0);

        final ResultChecker checker = new ResultChecker((settings.clientNumber * 3) / 2);

        for (int j = 0; j < settings.clientNumber; j++) {
            new Thread(() -> {
                try {
                    new TansClientRunner(settings)
                            .setStartLatch(startLatch)
                            .setChecker(checker)
                            .setMillis(millis)
                            .setTimes(times)
                            .execute();
                }
                catch (Exception e) {
                    System.out.println("Exec end with exception");
                    e.printStackTrace();
                }
                finally {
                    endLatch.countDown();
                }
            }, "Worker-" + j).start();
        }

        Thread.sleep(5000);
        System.out.println("Start " + new Date());
        startLatch.countDown();

        StopWatch watch = StopWatch.createStarted();

        endLatch.await();
        System.out.println("End " + new Date());

        watch.stop();
        double sec = watch.getTime(TimeUnit.MILLISECONDS) / 1000.0;

        System.out.println(String.format("Total finish %d in %.2f seconds, OPS is %.1f",
                times.get(), sec, times.get() / sec));

        checker.printCheckResult();
    }
    public static void main(String[] args) throws Exception {
        System.setProperty("node-id", "client");

        Settings settings = parseArgs(args);
        do{
            run(settings);
        }while(settings.forever);
    }

    public static class TansClientRunner {
        private Settings settings;
        private CountDownLatch startLatch;
        private ResultChecker checker;
        private AtomicLong millis;
        private AtomicLong times;

        public TansClientRunner(Settings settings) {
            this.settings = settings;
        }

        public void execute() throws Exception {
            //final TansClient client = new TansHttpClient(settings.servers.split(";"), settings.token);
            final TansClient client = new TansApacheClient(settings.servers.split(";"), settings.token);
            final int interval = settings.printInterval > 10 ? settings.printInterval + (int) (Math.random() * 100) : settings.printInterval;

            Thread.sleep(1000);
            startLatch.await();

            StopWatch watch = StopWatch.createStarted();
            try {
                for (int i = 0; i < settings.times; i++) {
                    String key = settings.prefix + "-" + (i % settings.keyNumber);
                    Range<Long> r = client.acquire(key, 1 + (i % 10), settings.ignoreLeader);
                    checker.accept(key, r.getMinimum(), r.getMaximum());
                    if (interval != 0 && i % interval == 0) {
                        System.out.println(String.format("[%s], %d, %s, %s", Thread.currentThread().getName(), i, key, r.toString()));
                    }
                }
            }
            finally {
                watch.stop();
                long m = watch.getTime(TimeUnit.MILLISECONDS);
                double sec = m / 1000.0;

                millis.addAndGet(m);
                times.addAndGet(settings.times);

                System.out.println(String.format("%s finish %d in %.2f seconds, OPS is %.1f, DUR is %.1f ms, HTTP DUR is %.1f ms",
                        Thread.currentThread().getName(), settings.times, sec, settings.times / sec, ((double) m) / settings.times,
                        client.durationMillisPerRequest()));

                client.close();
            }
        }

        public TansClientRunner setStartLatch(CountDownLatch startLatch) {
            this.startLatch = startLatch;
            return this;
        }

        public TansClientRunner setChecker(ResultChecker checker) {
            this.checker = checker;
            return this;
        }

        public TansClientRunner setMillis(AtomicLong millis) {
            this.millis = millis;
            return this;
        }

        public TansClientRunner setTimes(AtomicLong times) {
            this.times = times;
            return this;
        }
    }

    public static class ResultChecker {
        private int limit;
        ConcurrentMap<String, RangeCombinator> combinatorMap = new ConcurrentHashMap<>();

        public ResultChecker(int limit) {
            this.limit = limit;
        }

        public void accept(String key, long low, long high) {
            RangeCombinator combinator = this.combinatorMap.computeIfAbsent(key, k -> new RangeCombinator(k, this.limit));
            combinator.accept(low, high);
        }

        public void printCheckResult() {
            List<String> keys = new ArrayList<>(combinatorMap.keySet());
            keys.sort(String::compareTo);

            boolean errorOccur = false;
            for (String key : keys) {
                RangeCombinator c = combinatorMap.get(key);
                if (c.getErrMsg() != null) {
                    errorOccur = true;
                    System.out.println(key + ": " + c.getErrMsg());
                }
            }

            if (!errorOccur) {
                System.out.println("All " + keys.size() + " keys are ok");
            }
        }
    }

    public static class RangeCombinator {
        private String key;
        private int limit;
        private long last = 0;
        private String errMsg;
        private SortedSet<Range<Long>> ranges = new TreeSet<>(Comparator.comparingLong(Range::getMinimum));

        public RangeCombinator(String key, int limit) {
            this.limit = limit;
            this.key = key;
        }

        public synchronized void accept(long low, long high) {
            if (errMsg != null) {
                return;
            }

            int size = ranges.size();
            ranges.add(Range.between(low, high));
            if (ranges.size() == size) {
                errMsg = String.format("Overlapped [%d, %d]", low, high);
                return;
            }

            if (ranges.size() > this.limit) {
                tryConcat(this.limit + 1);
            }
        }

        public String getErrMsg() {
            if (errMsg == null) {
                tryConcat(0);
            }

            return this.errMsg;
        }

        private void tryConcat(int allowRemain) {
            while (!this.ranges.isEmpty()) {
                Range<Long> r0 = ranges.first();

                if (last == 0 || r0.getMinimum() == last + 1) {
                    last = r0.getMaximum();
                    ranges.remove(r0);
                }
                else {
                    if (r0.getMinimum() <= last) {
                        errMsg = String.format("Overlapped [%d, %d]", r0.getMinimum(), r0.getMaximum());
                        break;
                    }
                    if (r0.getMinimum() > last + 1) {
                        if (ranges.size() > allowRemain) {
                            errMsg = String.format("gap between %d, %s", last, r0.toString());
                        }
                        break;
                    }
                }
            }
        }
    }
}
